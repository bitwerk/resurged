package org.resurged.impl.marshalling;

import java.lang.reflect.Field;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.HashMap;

import org.resurged.impl.Log;
import org.resurged.jdbc.AutoGeneratedKeys;
import org.resurged.jdbc.ResultColumn;
import org.resurged.jdbc.SQLRuntimeException;



public class Marshaller <T> {
	HashMap<String, FieldMarshaller> fieldMarshallers = new HashMap<String, FieldMarshaller>();
	private final Class<T> type;
	private boolean isReturnKeys;
	
	public Marshaller(Class<T> type) {
		this.type = type;
		
		try{
			AutoGeneratedKeys annotation = type.getAnnotation(AutoGeneratedKeys.class);
			if(annotation!=null)
				isReturnKeys=true;
		}catch (Exception e) {}
		
		try{ 
			type.getConstructor();
		}catch (NoSuchMethodException e) {
			throw new RuntimeException(type.getName() + " must have a no-args constructor!");
		}
		
		Field[] declaredFields = type.getDeclaredFields();
		for (int i = 0; i < declaredFields.length; i++) {
			FieldMarshaller fieldMarshaller = new FieldMarshaller(declaredFields[i]);
			fieldMarshallers.put(fieldMarshaller.getFieldName(), fieldMarshaller);
		}
	}

	public T getObject(ResultSet rs) throws SQLException {
		try {
			T object = type.newInstance();

			ResultSetMetaData meta = rs.getMetaData();
			int colCount = meta.getColumnCount();
			
			Field[] keyFields=type.getDeclaredFields();
			if(isReturnKeys && keyFields.length!=colCount)
				throw new SQLRuntimeException("Expected number of auto generated keys returned was " + keyFields.length + ", but actual number of keys returned was " + colCount);
			
			for(int i=1;i<=meta.getColumnCount();i++){
				String columnName = meta.getColumnName(i);
				FieldMarshaller fieldMarshaller = null;
				if(fieldMarshallers.containsKey(columnName)){
					fieldMarshaller = fieldMarshallers.get(columnName);
				} else {
					for(String key: fieldMarshallers.keySet()){
						if(key.equalsIgnoreCase(columnName)){
							fieldMarshaller = fieldMarshallers.get(key);
						}
					}
					if(fieldMarshaller != null){
						// Change fieldMarshaller key to correct case
						fieldMarshallers.remove(fieldMarshaller);
						fieldMarshallers.put(columnName, fieldMarshaller);
					}
				}
				if(fieldMarshaller != null){
					if(isReturnKeys && keyFields.length==1)
						fieldMarshaller.retrieveFieldValue(rs, object, 1);
					else
						fieldMarshaller.retrieveFieldValue(rs, object, -1);
				}else if(isReturnKeys && keyFields.length==1){
					FieldMarshaller fm = new FieldMarshaller(keyFields[0]);
					fieldMarshallers.put(columnName, fm);
					fm.retrieveFieldValue(rs, object, 1);
				}
			}
			return object;
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
}
class FieldMarshaller{
	private String fieldName;
	private Field field;
	
	public FieldMarshaller(Field field) {
		this.field = field;
		
		if(field.isAnnotationPresent(ResultColumn.class)){
			ResultColumn annotation = (ResultColumn) field.getAnnotation(ResultColumn.class);
			String annotationValue=annotation.value();
			String annotationName=annotation.name();
			
			if(annotationValue.trim().length()==0 && annotationName.trim().length()==0)
				throw new SQLRuntimeException("@" + annotation.getClass().getSimpleName() + " Either the name or value attribute must be provided");
			else if(annotationValue.trim().length()>0 && annotationName.trim().length()>0)
				throw new SQLRuntimeException("@" + annotation.getClass().getSimpleName() + " Only the name or value attribute must be provided");
			
			fieldName=(annotationValue.trim().length()>0)?annotationValue:annotationName;
		} else {
			fieldName = field.getName();
		}
	}
	
	public void retrieveFieldValue(ResultSet rs, Object o, int index) throws Exception{
		boolean accessible = field.isAccessible(); 
		if(!accessible)
			field.setAccessible(true);
		
		if(index<0)
			Log.trace(this, "Geting " + fieldName);
		else
			Log.trace(this, "Geting field " + index);
		Object value =(index<0)? rs.getObject(fieldName) : rs.getObject(index);
		
		if(value!=null && value instanceof Integer &&(field.getType()==Byte.TYPE || field.getType()==Byte.class))
			field.set(o, ((Integer)value).byteValue());
		else if(value!=null && value instanceof Integer &&(field.getType()==Short.TYPE || field.getType()==Short.class))
			field.set(o, ((Integer)value).shortValue());
		else if(value!=null && value instanceof Long &&(field.getType()==Integer.TYPE || field.getType()==Integer.class))
			field.set(o, ((Long)value).intValue());
		else if(value!=null && value instanceof Double &&(field.getType()==Float.TYPE || field.getType()==Float.class))
			field.set(o, ((Double)value).floatValue());
		else if(value!=null && value instanceof Integer &&(field.getType()==Boolean.TYPE || field.getType()==Boolean.class))
			field.set(o, ((Integer)value)!=0);
		else
			field.set(o, value);

		if(!accessible)
			field.setAccessible(false);
	}

	public String getFieldName() {
		return fieldName;
	}
}